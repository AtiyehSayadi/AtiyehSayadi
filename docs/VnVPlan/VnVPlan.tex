\documentclass[12pt, titlepage]{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}

\input{../Comments}
\input{../Common}

\begin{document}

\title{ System Verification and Validation Plan for Centrality in Graphs{}} 
\author{Atiyeh Sayadi}
\date{\today}
	
\maketitle

\pagenumbering{roman}

\section*{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Feburary 14,  2024 & 1.0 & Initial draft\\
March 22, 2024& 1.1 & Second review\\
April 1, 2024& 1.2 & Unit testing\\
\bottomrule
\end{tabularx}

~\\


\newpage

\tableofcontents

\listoftables


\listoffigures

\newpage

\section{Symbols, Abbreviations, and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  CC& Closeness Centrality \\
  CD& Degree Centrality  \\
SRS & Software Requirment Specification\\
MG& Module Guide\\
MIS& Module Interface Specification\\
VnV& Verification and Validation\\
  \bottomrule
\end{tabular}\\

This section includes symbols and symbols used for developing this document.


\newpage

\pagenumbering{arabic}

\section{Introduction}


This document is created to review and confirm the project from its early stages of project clarification to design and implementation. It will cover various aspects, including setting up documents and using different techniques and tools for testing the project.

\section{General Information}
In this section, a brief overview of the project and its dimensions for testing purposes, as well as the purpose of writing this document and the documents used in drafting this project, are provided.

\subsection{Summary}

We want to design software that calculates closeness centrality and degree centrality for each node in a given graph, represented in the form of a numerical matrix of nodes and edges. Since this software is computational in nature, the accuracy and performance of functions and modules, including the  main modules that calculate closeness centrality and degree centrality, are crucial. Therefore, it is necessary for this software to be tested and validated from various aspects. This document serves as a roadmap for testing this software from pre-development to post-development stages.
\subsection{Objectives}

The purpose of developing this document is to ensure the accuracy and reliability of the project from various aspects. Accordingly, it is necessary for the project to be tested from different perspectives and stages based on the defined requirements. Since the functional requirements of the final system are defined based on the accuracy and precision of the outputs, this issue encompasses a significant portion of the tests. Additionally, since this system will provide a simple user interface, it does not seem necessary to perform usability testing for non-functional requirements. Furthermore, due to time constraints, it is not feasible to install the software on various systems to fully assess its portability.
\subsection{Relevant Documentation}

At this stage of document setup, other documents such as the Software Requirements Specification (\href{https://github.com/AtiyehSayadi/Centrality-In-Graphs/blob/main/docs/SRS/SRS.pdf}{SRS}),  the \href{https://github.com/AtiyehSayadi/Centrality-In-Graphs/blob/main/docs/Design/SoftDetailedDes/MIS.pdf}{MIS} and \href{https://github.com/AtiyehSayadi/Centrality-In-Graphs/blob/main/docs/Design/SoftArchitecture/MG.pdf}{MG} have been utilized. This is because at this stage, it is necessary to specify the development objectives, requirements, assumptions, and constraints of the software, and accordingly, testing is conducted. Additionally, precise computational algorithms need to be identified to assess their accuracy and precision. All of these aspects are summarized in these documents.


\section{Plan}
The purpose of this section is to identify and examine various aspects and relevant items related to this project for testing. In the first stage, it is necessary to identify which individuals are involved in testing this project and what each person's role is. Then, the Software Requirements Specification (SRS) document is reviewed as the first important document for testing this software. Following that, the testing procedure for design documents, including even this test document, is examined, and then the final software testing is introduced. Since testing is carried out both automatically and manually, automated testing tools will also be introduced.

\subsection{Verification and Validation Team}

This software is being developed individually. Therefore, initially, it is the developer's responsibility to ensure the correctness of its functioning and a proper understanding of the requirements. Additionally, reviewers can inform about any issues encountered during each stage of development. The list of individuals and their responsibilities is provided in Table 1.


\begin{table}[h!]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
 \textbf{Reviewers	}& \textbf{SRS }& \textbf{VnV}& \textbf{MIS/MG} \\
\hline
Atiyeh Sayadi& X& X& X \\ \hline
Yiding Li & X& X& X \\ \hline
Tanya Djavaherpour& X&  & \\ \hline
Cynthia Liu&  & X& \\ \hline
Waqar Awan& & & X \\ \hline
Dr.Spencer Smith& X& X& X \\ \hline
\end{tabular}
\caption{The table represents the responsibility of each team member. }
\label{Table:2}
\end{table}

\newpage
\subsection{SRS Verification Plan}

The SRS document can be verified by reviewers according to the following:\\
1- Confirmation of project requirements and assumptions.\\
2- Confirmation of project objectives aligned with requirements.\\
3- Confirmation of the clarity in explaining algorithms, their concepts, and their applicability.\\

Process: The document is uploaded to GitHub. Relevant reviewers examine it and provide their feedback in the form of issues.

\subsection{Design Verification Plan}
The design phase is an intermediate and critical stage where the final software is designed based on features, requirements, and assumptions. In this section, the main functions and modules are designed. Therefore, reviewers need to examine whether this project has been designed practically and correctly in accordance with its objectives and requirements.\\

Process: The document is uploaded to GitHub. Relevant reviewers examine it and provide their feedback in the form of issues.

\subsection{Verification and Validation Plan Verification Plan}
In software development, all stages, including software testing, require verification. In this regard, it is necessary to examine whether the tests planned for the software are sufficient or not. Additionally, sometimes some tests are overly complex or impractical to execute, and they need to be identified and removed from the verification process. This confirmation is carried out by reviewers.\\

Process: The document is uploaded to GitHub. Relevant reviewers examine it and provide their feedback in the form of issues.
\subsection{Implementation Verification Plan}



In the final stage, the software needs to be approved. This approval involves:\\
1. Verification of whether the software has been developed according to the requirements, goals, algorithms, and assumptions specified in the SRS document or not.\\
2. Checking whether the final software conforms to the design documents from various aspects or not.\\
3. Ensuring whether the output is clear or not.\\
In this stage, besides the review conducted by the Dr.Spencer Smith, it is necessary to develop automated tests to confirm the accuracy of the software from various aspects.
\subsection{Automated Testing and Verification Tools}

As mentioned, this software will primarily be tested for accuracy and performance. Additionally, the focus will be mainly on unit testing and system testing. Therefore, Pytest will be used for testing this software. Furthermore, for addressing issues related to coding errors and standardizing them, pylint will be utilized.

\subsection{Software Validation Plan}

To validate any software, it is necessary to first verify it from various aspects. After the software has been verified, the project owner needs to validate it. This project will be validated by Dr. Spencer Smith.

\section{System Test Description}
	
\subsection{Tests for Functional Requirements}
In this section, the specific items to be tested in the software are described in detail.


%\subsubsection{Input Testing}
%In this section, it will be determined how the input of the program should be tested for conformity to standards.
		
%\paragraph{Input Testing}

%\begin{enumerate}

%\item{Input Testing\\}

%Control: Automatic
					
%Initial State: True 
					
%Input: Input Matrix (The given graph matrix)
					
%Output: True or False
					
%How test will be performed: This test demonstrates that the input matrix is in the standard size.
					

%\end{enumerate}

\subsubsection{Degree Centrality Testing}

In this section, the outputs related to degree centrality are being tested.
\begin{enumerate}

\item{Test1: Bound Testing\\}	
Control: Automatic\\				
Initial State: null
					
Input:  The outputs of degree centrality calculations.
					
Output: nodes that their values of cenrality are out of bound.

Test Case Derivation: Based on requirements 1 and 2 of this project, it is necessary for the degree centrality to be accurately calculated for all nodes. We know that this metric for each node is between zero and one. Therefore, a function needs to be written to evaluate this value for each node based on the allowable range and report any discrepancies found.






How test will be performed: It dermindes nodes that their centrality are less than 0 or more than 1.


\end{enumerate}
\subsubsection{Closeness Centrality Testing}

In this section, the outputs related to calculating closeness centrality are being tested.

\begin{enumerate}

\item{Test2: Bound Testing\\}	
Control: Automatic	\\			
Initial State: null
					
Input:  The outputs of degree centrality calculations.
					
Output: nodes that their values of cenrality are out of bound

Test Case Derivation: Based on requirements 3 and 4 of this project, it is necessary for the closeness centrality to be accurately calculated for all nodes. We know that this metric for each node is between zero and one. Therefore, a function needs to be written to evaluate this value for each node based on the allowable range and report any discrepancies found.

How test will be performed: It dermindes nodes that their centrality are less than 0 or more than 1.




\end{enumerate}

\subsection{Tests for Nonfunctional Requirements}
Since resources and time for developing this software are limited, the only test conducted in this regard is maintainability and accuracy testing. 

\subsubsection{maintainability}
		

\begin{enumerate}

\item{Test3: Code Testing\\}

Type: Automatic
					
Initial State: -
					
Input/Condition: Program code
					
Output/Result: Coding errors

Test Case Derivation: Using the pylint module
					
How test will be performed:  Highlighted are the areas where programming standards have not been followed, with explanations provided in the terminal.
\end{enumerate}
\subsubsection{Accuracy}
\begin{enumerate}
\item{Test4: Correctness Testing for DC\\}

Control: Automatic
					
Initial State: null
					
Input:  The outputs of degree  centrality calculations.
					
Output: Nodes whose centrality contradicts what is calculated by library functions for this criterion.

Test Case Derivation: Using the NetworkX library functions in Python, the centrality of each node is calculated for the given graph, and it is compared with the output of the program(Based on requirements 1 and 2).

How test will be performed: Nodes for which the calculated centrality differs from the library function output are displayed.

\item{Test5: Correctness Testing for CC\\}

Control: Automatic
					
Initial State: null
					
Input: The outputs of closeness centrality calculations.
					
Output: Nodes whose centrality contradicts what is calculated by library functions for this criterion.

Test Case Derivation: Using the NetworkX library functions in Python, the centrality of each node is calculated for the given graph, and it is compared with the output of the program(Based on requirements 3 and 4).

How test will be performed: Nodes for which the calculated centrality differs from the library function output are displayed.

\subsection{Traceability Between Test Cases and Requirements}


\end{enumerate}
\begin{table}[h!]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
	&FR1 &FR2 & FR3 & FR4 &NFR1 &NFR2 & NFR3 & NFR4\\
\hline
Test 1     & X& X&  &  & X & & & \\ \hline
Test 2    & &   &  X&X  & X & & & \\ \hline
Test 3     &   &   &  &  & X & & X& \\ \hline
Test 4     &X  &X   &  &  & X & & & \\ \hline
Test 5    &  &  & X & X &  & & & \\ \hline

\end{tabular}
\caption{Traceability Matrix Showing the Connections Between Tests and Requirments in SRS}
\label{Table:A_trace}
\end{table}
\newpage
\section{Unit Test Description}

In this section, various software modules and the performance of their functions are tested based on the MIS and MG documents. According to these two documents, this software consists of three main modules: File, Graph, and ShowGraph, with the primary computational burden of this software falling on the Graph module. Since the other two modules do not perform primary computations, Therefore, these tests mostly cover the internal functions of the graph module. All automated tests are available in  \href{https://github.com/AtiyehSayadi/Centrality-In-Graphs/tree/main/test/test_graph.py}{test\_graph.py} .

\subsection{Unit Testing Scope}


As mentioned earlier, tests are mainly focused on the Graph module, which carries the main computational load and ensures the correct functionality of the program. 

\subsection{Tests for Functional Requirements}

In this section, the tests considered for each module are titled according to functional requirements.

\subsubsection{Graph File}
No test has been considered for this module.
\subsubsection{Graph Module}

As previously mentioned, the main computations of this software are performed by this module, which includes functions such as computing degree centrality, closeness centrality, node degree, and etc.. Therefore, each of these functions can be separately examined for accuracy and correctness to ensure the validity of the software.

\begin{enumerate}

\item{Test1: test\_degree\_centrality}

Type: Automatic
					
Initial State:-
					
Input: -
					
Output:Function approval or disapproval
Test Case Derivation: Exception for nodes with non-zero obtained values.
How test will be performed: Since the graph is stored in the form of an adjacency matrix, node indices should not be outside the matrix bounds. Otherwise, this function will consider the value zero for such indices. This test measures the output of the function for out-of-range indices.
					
\item{Test2: test\_closeness\_centrality}

Type: Automatic
					
Initial State:-
					
Input: -
					
Output:Function approval or disapproval
Test Case Derivation: Exception for nodes with non-zero obtained values.
How test will be performed: Since the graph is stored in the form of an adjacency matrix, node indices should not be outside the matrix bounds. Otherwise, this function will consider the value zero for such indices. This test measures the output of the function for out-of-range indices.
					

\item{Test3: test\_exist}

Type: Automatic
					
Initial State:-
					
Input: -
					
Output:Confirmation or disconfirmation of the expected behavior of the {exist\_edge} function.
Test Case Derivation: Exception for nodes with true obtained values.
How test will be performed:This test is designed for the edge existence checking function in the graph. If the edge is outside the graph's bounds, the output value should be false.
							
\item{Test4: test\_degree}

Type: Automatic
					
Initial State:-
					
Input: -
					
Output:Confirmation or disconfirmation of the expected behavior of the {get\_degree }function.
Test Case Derivation: Exception for nodes with non-zero obtained values.
How test will be performed: Since the graph is stored in the form of an adjacency matrix, node indices should not be outside the matrix bounds. Otherwise, this function will consider the value zero for such indices. This test measures the output of the function for out-of-range indices.
					


\item{Test5: test\_shortest\_path}

Type: Automatic
					
Initial State:-
					
Input: -
					
Output:Confirmation or disconfirmation of the expected behavior of the {get\_shortest\_path}function.
Test Case Derivation: Exception for paths with non-infinite obtained values.
How test will be performed: Since the graph is stored in the form of an adjacency matrix, node indices should not be outside the matrix bounds. Otherwise, this function will consider the value infinite for such indices. This test measures the output of the function for out-of-range indices.
				



    
\end{enumerate}

\subsubsection{Show Graph}
No test has been considered for this module.

\subsection{Tests for Nonfunctional Requirements}

In addition to the functional requirements, it is necessary to test the modules based on non-functional requirements as well. Since one of these requirements is the accuracy of the output, this will be examined based on the tests performed for the graph module in the previous section. Additionally, since a simple graphical interface is considered for this software, implemented by the ShowGraph module, usability testing for it is not of great importance. Furthermore, in designing this software, an attempt has been made to utilize a hierarchical modular design approach with minimal side effects, which can serve as confirmation of its maintainability. The only test considered in this section is the accuracy test of the software's performance based on various inputs, which involves all modules.
		

\subsubsection{Graph Module}
\begin{enumerate}
\item{Test5: Itest\_disconnect\\}

Type: Automatic
					
Initial State: -
					
Input/Condition: Disconnected graph as the input file. (\href{https://github.com/AtiyehSayadi/Centrality-In-Graphs/tree/main/test/disconnect.txt}{disconnecttxt} )
					
Output/Result:  The module's performance for disconnected graphs.
					
How test will be performed: Closeness centrality is a metric that is only considered for connected graphs because otherwise the sum of the lengths of the shortest paths to other nodes for each node is considered infinite. Therefore, this function should be able to consider a closeness centrality value of zero for all nodes in disconnected graphs.
 \end{enumerate}
\subsubsection{ShowGraph}
\begin{enumerate}
\item{Test6: Big\_data\\}

Type: Automatic
					
Initial State: -
					
Input/Condition: Big graph as the input file
					
Output/Result:  The module's performance for big graphs.
					
How test will be performed: The software should be able to perform computations for heavier data and larger graphs and display the output. In this test, Facebook company data(\href{https://github.com/AtiyehSayadi/Centrality-In-Graphs/tree/main/test/facebook_combined.txt}{facebook\_combined.txt} ), extracted from the \href{https://snap.stanford.edu/data/}{Stanford} website, is inputted into the system as an example of a directed graph.
\end{enumerate}

\subsection{Traceability Between Test Cases and Modules}
\begin{table}[h!]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
	&File &Graph &ShowGraph\\
\hline
Test 1     & & X&  \\ \hline
Test 2     & & X&  \\ \hline
Test 3    & & X&  \\ \hline
Test 4     & & X&  \\ \hline
Test 5     & & X&  \\ \hline
Test 6     &X & &  \\ \hline

\end{tabular}
\caption{Traceability Matrix Showing the Connections Between Tests and Modules}
\label{Table:A_trace}
\end{table}

				
\bibliographystyle{plainnat}

\newpage

\section{Appendix}

As previously mentioned, this document aims to provide information about testing a software project from start to finish, covering different methods and aspects. Therefore, this document will assist in achieving a more precise and targeted testing and validation process.

\subsection{Symbolic Parameters}

In the development of this document, no symbolic constants have been used.
\subsection{Usability Survey Questions?}

Since the development of a graphical interface is not part of the development agenda for this project, no description can be considered for this section.Since the user interface designed for this software is very simple, the only question is whether the outputs are clear enough.

\newpage{}


\end{document}